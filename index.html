<!DOCTYPE html>
<html>
<head>
  <title>PDF QR Sorter</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://unpkg.com/pdf-lib"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
  .guide {
    position: fixed;
    top: 0; left: 0; bottom: 0; right: 0;
    background-color: rgba(0,0,0,0.4);
    display: none;
    z-index: 1050;
  }
  .guide div {
    position: fixed;
    top: 0;
    right: -700px;
    height: 100%;
    width: 650px;
    background: white;
    box-shadow: -2px 0 8px rgba(0,0,0,0.2);
    transition: right 0.3s ease-in-out;
    z-index: 1060;
    overflow-y: auto;
    padding: 20px;
  }
  .guide .open {
    right: 0;
  }
  .guide img{
      width: 80%;
      margin: 2px 10%;
  }
.carousel-control-prev-icon, .carousel-control-next-icon {
    filter: invert(100%);
}

  .progress-container {
    margin: 20px 0;
  }
  
  .status-message {
    margin: 10px 0;
    padding: 10px;
    background-color: #f8f9fa;
    border-left: 4px solid #007bff;
    border-radius: 4px;
  }
  
  .status-message.error {
    background-color: #fff5f5;
    border-color: #dc3545;
    color: #721c24;
  }
  
  .status-message.warning {
    background-color: #fffbf0;
    border-color: #ffc107;
    color: #856404;
  }
  
  .spinner-border-sm {
    width: 1rem;
    height: 1rem;
  }

  .error-log {
    max-height: 200px;
    overflow-y: auto;
    font-family: monospace;
    font-size: 0.9em;
    background: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    padding: 10px;
  }

  .recovery-controls {
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    border-radius: 4px;
    padding: 15px;
    margin: 15px 0;
  }

  .json-export {
    background: #d1ecf1;
    border: 1px solid #bee5eb;
    border-radius: 4px;
    padding: 15px;
    margin: 15px 0;
  }

  </style>
</head>
<body class="container my-4">

<h1>CBGU Doc Control PDF Sorter</h1>
<button class="btn btn-outline-info mb-3" onclick="toggleGuide('guideScan',true)">📘 View Scan Guide </button>
<button class="btn btn-outline-info mb-3" onclick="toggleGuide('guideDocs',true)">📘 View Word Docs Generation Guide </button>

<div id="guideScan" class="guide" onclick="toggleGuide('guideScan',false)">
  <div onclick="event.stopPropagation()">
    <h4>Scan Guide</h4>
    <p>To ensure correct QR detection open the option window in the email scanning page:</p>
    <img src="image/selectOptions.png"></img>
    <p> 1. Ensure a resolution of 300 DPI is set.</p>
    <img src="image/firstSelect.png"></img>
    <p> 2. Select Color Mode, and set it to Color</p>
    <img src="image/secondSelect.png"></img>
    <p> 3. Select the Optimize Text/Picture, and Select Photograph</p>
    <img src="image/finalStep.png"></img>
    <p> 4. When Scanning make sure QR codes are not cropped, or covered</p>
    <p class="alert alert-warning">If there is an error with scanning the QR Code, you'd be able to mannually enter it in</p>
  </div>
</div>

<div id="guideDocs" class="guide" onclick="toggleGuide('guideDocs',false)">
<div onclick="event.stopPropagation()">
<h4>Document Creation Guide</h4>
    
    <p><strong>Adding QR Codes in Microsoft Word using DisplayBarcode</strong></p>
    <ol>
      <li>Open your Word document.</li>
      <li>Place the cursor where you want the QR code.</li>
      <li>Press <code>Ctrl + F9</code> to insert a field (you must use <code>Ctrl + F9</code> to get the special field brackets).</li>
      <li>Type or paste something like this:<br>
        <code>{ DISPLAYBARCODE "Your Data Here" QR \s 100 }</code>
      </li>
      <li>Right-click the field and choose <strong>Update Field</strong>.</li>
    </ol>

    <p>Use the generator below to create your field code with a title, optional prefix, custom date parts, and separator.</p>

    <hr>

    <h4>QR Code Field Generator</h4>

<form id="qrForm" style="display: grid; gap: 12px;">

  <label>
    Prefix:<br>
    <input type="text" id="prefix" class="form-control" placeholder="e.g., DOC" style="width: 100%;">
  </label>

  <label style="display: flex; align-items: center; gap: 6px;">
    <input type="checkbox" id="useMerge" checked>
    Use MERGEFIELD for title
  </label>
  <label>
    Custom MERGEFIELD:<br>
    <input type="text" id="custMerge" placeholder="documentid" class="form-control" style="width: 100%;">
  </label>

  <fieldset style="border: 1px solid #ccc; padding: 10px; border-radius: 6px;">
    <legend style="padding: 0 5px;">Date Format Parts</legend>
    
    <label>
      Day Format:<br>
      <select id="dayFormat" class="form-select" style="width: 100%;">
        <option value="dd">dd (two digits)</option>
        <option value="d">d (one or two digits)</option>
      </select>
    </label>

    <label>
      Month Format:<br>
      <select class="form-select" id="monthFormat" style="width: 100%;">
        <option value="MM">MM (two digits)</option>
        <option value="M">M (one or two digits)</option>
      </select>
    </label>

    <label>
      Year Format:<br>
      <select class="form-select" id="yearFormat" style="width: 100%;">
        <option value="yyyy">yyyy (four digits)</option>
        <option value="yy">yy (two digits)</option>
      </select>
    </label>

    <label>
      Date Order:<br>
      <select class="form-select" id="dateOrder" style="width: 100%;">
        <option value="DMY">Day - Month - Year</option>
        <option value="MDY">Month - Day - Year</option>
        <option value="YMD">Year - Month - Day</option>
        <option value="MY">Month - Year</option>
        <option value="YM">Year - Month</option>
        <option value="DY">Day - Year</option>
        <option value="YD">Year - Day</option>
        <option value="DM">Day - Month</option>
        <option value="MD">Month - Day</option>
        <option value="Y">Year</option>
      </select>
    </label>
  </fieldset>

  <label>
    Separator:<br>
    <input type="text" id="separator" class="form-control" value="-" maxlength="2" style="width: 60px;">
  </label>

  <label>
    Barcode Size:<br>
    <span style="display:flex;">
        <input type="range" id="sizeRange" class="form-range" min="10" max="400" value="100" style="width: 85%;margin:auto">
        <input type="number" id="sizeNumber" class="form-control" min="10" max="400" value="100" style="width: 15%; margin: 0 15px;">
    </span>
  </label>

</form>

    <h5 style="margin-top:20px;">Generated Word Field Code:</h5>
    <span class="input-group" >
        <input input="text" class="form-control" id="formoutput" disabled> </input>
        <span class="input-group-append">
            <button id="copyBtn" class="btn btn-outline-secondary" type="button">Copy</button>
        </span>
</span>


    <h5>Preview of Final Barcode Value (Fake):</h5>
    <pre id="preview" style="background:#e8ffe8; padding:10px; border-radius:4px; max-height:80px; overflow:auto;"></pre>

    <script>
        document.getElementById("copyBtn").addEventListener("click", () => {
            const output = document.getElementById("formoutput").value;
            navigator.clipboard.writeText(output).then(() => {
                const btn = document.getElementById("copyBtn");
                btn.textContent = "Copied!";
                setTimeout(() => btn.textContent = "Copy", 1500);
            }).catch(() => {
                alert("Failed to copy. Try manually.");
            });
        });

        function generate() {
            const prefix = document.getElementById("prefix").value.trim();
            const useMerge = document.getElementById("useMerge").checked;
            const custMerge = document.getElementById("custMerge").value.trim();

            const dayFmt = document.getElementById("dayFormat").value;
            const monthFmt = document.getElementById("monthFormat").value;
            const yearFmt = document.getElementById("yearFormat").value;
            const order = document.getElementById("dateOrder").value;

            const separator = document.getElementById("separator").value;
            const size = parseInt(document.getElementById("sizeNumber").value, 10);

            // Build date parts map for Word format and preview
            const datePartsMap = {
                D: { field: dayFmt, preview: formatDatePart(dayFmt) },
                M: { field: monthFmt, preview: formatDatePart(monthFmt, true) },
                Y: { field: yearFmt, preview: formatDatePart(yearFmt, false, true) }
            };

            // Helper to format preview date parts
            function formatDatePart(fmt, isMonth=false, isYear=false) {
                const now = new Date();
                if (isYear) {
                    if (fmt === "yyyy") return now.getFullYear();
                    if (fmt === "yy") return String(now.getFullYear()).slice(2);
                }
                if (isMonth) {
                    if (fmt === "MM") return String(now.getMonth() + 1).padStart(2, "0");
                    if (fmt === "M") return String(now.getMonth() + 1);
                }
                // Day
                if (fmt === "dd") return String(now.getDate()).padStart(2, "0");
                if (fmt === "d") return String(now.getDate());
                return "";
            }

            // Build date field string and preview string based on order
            const dateFields = [];
            const previewParts = [];

            for (const part of order) {
                if (datePartsMap[part]) {
                    dateFields.push(datePartsMap[part].field);
                    previewParts.push(datePartsMap[part].preview);
                }
            }

            const dateFieldFormat = dateFields.join(separator);
            const dateField = `{ DATE \\@ "${dateFieldFormat}" }`;
            const fakeDate = previewParts.join(separator);

            const titleField = useMerge ? `{ MERGEFIELD "Title" }` : '';
            const fakeTitle = useMerge ? "SampleTitle" : '';

            const mergeField = custMerge ? `{ MERGEFIELD "${custMerge}" }` : '';
            const fakeMerge = custMerge ? custMerge : '';
            const fieldParts = [];
            const previewOut = [];

            if (prefix) {
                fieldParts.push(prefix);
                previewOut.push(prefix);
            }
            if (titleField) {
                fieldParts.push(titleField);
                previewOut.push(fakeTitle);
            }
            if (mergeField){
                fieldParts.push(mergeField);
                previewOut.push(fakeMerge);
            }
            if (dateFieldFormat) {
                fieldParts.push(dateField);
                previewOut.push(fakeDate);
            }

            const content = fieldParts.join(separator);
            const previewContent = previewOut.join(separator);

            const field = `{ DISPLAYBARCODE "${content}" QR \\s ${size} }`;

            document.getElementById("formoutput").value = field;
            document.getElementById("preview").textContent = previewContent;
        }

        const sizeRange = document.getElementById("sizeRange");
        const sizeNumber = document.getElementById("sizeNumber");

        sizeRange.addEventListener("input", () => {
            sizeNumber.value = sizeRange.value;
            generate();
        });
        sizeNumber.addEventListener("input", () => {
            let val = parseInt(sizeNumber.value, 10);
            if (isNaN(val)) val = 10;
            if (val < 10) val = 10;
            if (val > 400) val = 400;
            sizeNumber.value = val;
            sizeRange.value = val;
            generate();
        });

        const inputs = document.querySelectorAll("#guideDocs input");
        inputs.forEach(input => input.addEventListener("input", () => {
            generate();
        }));
        inputs.forEach(input => input.addEventListener("change", () => {
            generate();
        }));
        const selects = document.querySelectorAll("#guideDocs select");
        selects.forEach(input => input.addEventListener("select", () => {
            generate();
        }));
        selects.forEach(input => input.addEventListener("change", () => {
            generate();
        }));
        // Init
        generate();
    </script>    
</div>
</div>

<input type="file" id="fileInput" accept="application/pdf" class="form-control mb-3" />

<!-- Progress section -->
<div id="progressSection" class="progress-container" style="display: none;">
  <div class="status-message" id="statusMessage">
    <div class="d-flex align-items-center">
      <div class="spinner-border spinner-border-sm me-2" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
      <span id="statusText">Initializing...</span>
    </div>
  </div>
  
  <div class="progress mb-3">
    <div class="progress-bar" id="progressBar" role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
  </div>
  
  <div class="row">
    <div class="col-md-6">
      <small class="text-muted">Render Progress: <span id="renderProgress">0/0</span></small>
    </div>
    <div class="col-md-6 text-end">
      <small class="text-muted">Process Progress: <span id="processProgress">0/0</span></small>
    </div>
  </div>

  <!-- Error Recovery Section -->
  <div id="errorRecoverySection" style="display: none;">
    <div class="recovery-controls">
      <h5>⚠️ Error Recovery Mode</h5>
      <p>An error occurred during processing. You can:</p>
      <div class="btn-group" role="group">
        <button class="btn btn-warning" onclick="skipCurrentPage()">Skip Current Page</button>
        <button class="btn btn-info" onclick="retryCurrentPage()">Retry Current Page</button>
        <button class="btn btn-success" onclick="continueWithPartialResults()">Use Partial Results</button>
        <button class="btn btn-danger" onclick="resetProcessing()">Reset & Start Over</button>
      </div>
    </div>
    
    <div class="json-export">
      <h6>Current Progress JSON:</h6>
      <div class="d-flex gap-2 mb-2">
        <button class="btn btn-sm btn-outline-primary" onclick="exportProgressJSON()">Download JSON</button>
        <button class="btn btn-sm btn-outline-secondary" onclick="copyProgressJSON()">Copy to Clipboard</button>
        <button class="btn btn-sm btn-outline-info" onclick="importProgressJSON()">Import JSON</button>
        <input type="file" id="jsonFileInput" accept=".json" style="display: none;" onchange="handleJSONImport(event)">
      </div>
      <pre id="progressJSON" class="error-log" style="max-height: 150px;"></pre>
    </div>
  </div>
</div>

<!-- Error Log Section -->
<div id="errorLogSection" class="error-log" style="display: none;">
  <h6>Error Log:</h6>
  <div id="errorLogContent"></div>
</div>

<div id="output" class="mb-3"></div>
<div id="downloads" class="mb-4"></div>
<div id="carouselGrid" class="row g-4"></div>

<!-- Image Preview Modal -->
<div class="modal fade" id="imagePreviewModal" tabindex="-1" aria-labelledby="imagePreviewLabel" aria-hidden="true">
  <div class="modal-dialog modal-xl modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
      <div class="modal-body p-0">
        <img id="previewImage" class="img-fluid w-100" style="object-fit: contain;" />
        <div id="errorCorrection" class="position-sticky bottom-0 bg-light p-3 border-top">
            <div class="input-group">
                <input type="text" class="form-control" id="correctionInput" placeholder="Type new name...">
                <button class="btn btn-outline-primary" onclick="syncCorrectionInput()">Use</button>
            </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
let originalPdfBytes = null;
let worker = null;
const images = [];
let sortedPages = null;
let processingState = {
  currentPage: 0,
  totalPages: 0,
  skippedPages: new Set(),
  errors: [],
  partialResults: {},
  processingStarted: false,
  currentErrorBatch: null,
  currentErrorPage: null,
  individualMode: false
};

function toggleGuide(id, show) {
    const overlay = document.getElementById(id);
    const sidebar = overlay.children[0];
    if (show) {
      overlay.style.display = 'block';
      setTimeout(() => sidebar.classList.add('open'), 10);
    } else {
      sidebar.classList.remove('open');
      setTimeout(() => overlay.style.display = 'none', 300);
    }
}

function updateProgress(current, total, type = 'general') {
    const percentage = Math.round((current / total) * 100);
    const progressBar = document.getElementById('progressBar');
    
    if (type === 'render') {
        document.getElementById('renderProgress').textContent = `${current}/${total}`;
        progressBar.style.width = `${percentage / 2}%`; // First half for rendering
    } else if (type === 'process') {
        document.getElementById('processProgress').textContent = `${current}/${total}`;
        progressBar.style.width = `${50 + (percentage / 2)}%`; // Second half for processing
        processingState.currentPage = current;
    } else {
        progressBar.style.width = `${percentage}%`;
    }
    
    progressBar.setAttribute('aria-valuenow', percentage);
}

function updateStatus(message, showSpinner = true, type = 'info') {
    const statusText = document.getElementById('statusText');
    const spinner = document.querySelector('.spinner-border');
    const statusMessage = document.getElementById('statusMessage');
    
    statusText.textContent = message;
    spinner.style.display = showSpinner ? 'inline-block' : 'none';
    
    // Update status message styling based on type
    statusMessage.className = `status-message ${type}`;
    
    // Log errors
    if (type === 'error') {
        logError(message);
    }
}

function logError(message) {
    const errorTime = new Date().toISOString();
    const errorEntry = `[${errorTime}] ${message}`;
    
    processingState.errors.push(errorEntry);
    
    const errorLogSection = document.getElementById('errorLogSection');
    const errorLogContent = document.getElementById('errorLogContent');
    
    errorLogSection.style.display = 'block';
    errorLogContent.innerHTML += `<div>${errorEntry}</div>`;
    errorLogContent.scrollTop = errorLogContent.scrollHeight;
    
    console.error(errorEntry);
}

function showProgress() {
    document.getElementById('progressSection').style.display = 'block';
}

function hideProgress() {
    document.getElementById('progressSection').style.display = 'none';
}

function showErrorRecovery() {
    document.getElementById('errorRecoverySection').style.display = 'block';
    updateProgressJSON();
}

function hideErrorRecovery() {
    document.getElementById('errorRecoverySection').style.display = 'none';
}

function updateProgressJSON() {
    const progressData = {
        timestamp: new Date().toISOString(),
        currentPage: processingState.currentPage,
        totalPages: processingState.totalPages,
        skippedPages: Array.from(processingState.skippedPages),
        partialResults: processingState.partialResults,
        errors: processingState.errors,
        imagesProcessed: images.length
    };
    
    document.getElementById('progressJSON').textContent = JSON.stringify(progressData, null, 2);
    return progressData;
}

function exportProgressJSON() {
    const progressData = updateProgressJSON();
    const blob = new Blob([JSON.stringify(progressData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `pdf_sorter_progress_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

function copyProgressJSON() {
    const progressData = updateProgressJSON();
    navigator.clipboard.writeText(JSON.stringify(progressData, null, 2)).then(() => {
        alert('Progress JSON copied to clipboard!');
    }).catch(() => {
        alert('Failed to copy to clipboard');
    });
}

function importProgressJSON() {
    document.getElementById('jsonFileInput').click();
}

function handleJSONImport(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const progressData = JSON.parse(e.target.result);
            
            // Restore processing state
            processingState.currentPage = progressData.currentPage || 0;
            processingState.totalPages = progressData.totalPages || 0;
            processingState.skippedPages = new Set(progressData.skippedPages || []);
            processingState.partialResults = progressData.partialResults || {};
            processingState.errors = progressData.errors || [];
            
            // Update UI
            updateStatus(`Imported progress from ${progressData.timestamp}`, false, 'info');
            updateProgressJSON();
            
            // If we have partial results, allow continuing
            if (Object.keys(processingState.partialResults).length > 0) {
                const continueBtn = document.createElement('button');
                continueBtn.className = 'btn btn-success mt-2';
                continueBtn.textContent = 'Continue from Imported Progress';
                continueBtn.onclick = () => {
                    sortedPages = processingState.partialResults;
                    processingComplete();
                    continueBtn.remove();
                };
                document.getElementById('errorRecoverySection').appendChild(continueBtn);
            }
            
        } catch (error) {
            updateStatus('Failed to import JSON: ' + error.message, false, 'error');
        }
    };
    reader.readAsText(file);
}

function skipCurrentPage() {
    if (processingState.currentErrorPage) {
        processingState.skippedPages.add(processingState.currentErrorPage);
        updateStatus(`Skipped page ${processingState.currentErrorPage}, continuing...`, true);
        
        // If we're in individual mode, continue from the next page in the error batch
        if (processingState.currentErrorBatch && processingState.individualMode) {
            continueIndividualProcessing(processingState.currentErrorPage);
        } else {
            // Continue processing from next page
            continueProcessingFromPage(processingState.currentErrorPage + 1);
        }
    } else {
        updateStatus('No current error page to skip', false, 'warning');
    }
}

function retryCurrentPage() {
    if (processingState.currentErrorPage) {
        updateStatus(`Retrying page ${processingState.currentErrorPage}...`, true);
        
        // If we're in individual mode, retry the current page in the error batch
        if (processingState.currentErrorBatch && processingState.individualMode) {
            continueIndividualProcessing(processingState.currentErrorPage - 1);
        } else {
            // Retry current page processing
            continueProcessingFromPage(processingState.currentErrorPage);
        }
    } else if (processingState.currentErrorBatch) {
        // Retry the entire batch that failed, but in individual mode
        updateStatus(`Retrying failed batch (pages ${processingState.currentErrorBatch.start + 1}-${processingState.currentErrorBatch.end}) in individual mode...`, true);
        processingState.individualMode = true;
        hideErrorRecovery();
        
        worker.postMessage({
            type: 'PROCESS_BATCH',
            data: { 
                startIndex: processingState.currentErrorBatch.start, 
                endIndex: processingState.currentErrorBatch.end,
                skipList: Array.from(processingState.skippedPages),
                individualMode: true
            }
        });
    } else {
        updateStatus('No current error to retry', false, 'warning');
    }
}

function continueWithPartialResults() {
    if (Object.keys(processingState.partialResults).length > 0) {
        sortedPages = processingState.partialResults;
        updateStatus('Using partial results', false, 'warning');
        hideErrorRecovery();
        processingComplete();
    } else {
        updateStatus('No partial results available', false, 'error');
    }
}

function resetProcessing() {
    // Reset all state
    processingState = {
        currentPage: 0,
        totalPages: 0,
        skippedPages: new Set(),
        errors: [],
        partialResults: {},
        processingStarted: false,
        currentErrorBatch: null,
        currentErrorPage: null,
        individualMode: false
    };
    
    images.length = 0;
    sortedPages = null;
    
    // Clear UI
    document.getElementById('output').innerHTML = '';
    document.getElementById('downloads').innerHTML = '';
    document.getElementById('carouselGrid').innerHTML = '';
    document.getElementById('errorLogSection').style.display = 'none';
    document.getElementById('errorLogContent').innerHTML = '';
    
    hideErrorRecovery();
    hideProgress();
    
    updateStatus('Processing reset. Please select a file to start over.', false);
}

async function continueProcessingFromPage(startPage) {
    if (!worker || !processingState.processingStarted) {
        updateStatus('Cannot continue: processing not initialized', false, 'error');
        return;
    }
    
    try {
        hideErrorRecovery();
        
        // Continue processing from specified page
        const remainingPages = processingState.totalPages - startPage + 1;
        
        if (remainingPages <= 0) {
            updateStatus('No more pages to process', false, 'info');
            // Get final results
            worker.postMessage({ type: 'GET_RESULTS' });
            return;
        }
        
        updateStatus(`Continuing processing from page ${startPage}...`, true);
        
        // Reset individual mode for new batches
        processingState.individualMode = false;
        processingState.currentErrorBatch = null;
        processingState.currentErrorPage = null;
        
        // Process remaining pages in normal batch mode
        await continueProcessingFromBatch(startPage - 1, false);
        
    } catch (error) {
        updateStatus('Error continuing processing: ' + error.message, false, 'error');
        showErrorRecovery();
    }
}

async function continueProcessingFromBatch(startIndex, individualMode = false) {
    const batchSize = 10;
    
    for (let i = startIndex; i < processingState.totalPages; i += batchSize) {
        const endIndex = Math.min(i + batchSize, processingState.totalPages);
        
        updateStatus(`Processing batch: pages ${i + 1}-${endIndex} of ${processingState.totalPages} ${individualMode ? '(individual mode)' : ''}...`);
        
        // Send batch processing request to worker
        await new Promise((resolve, reject) => {
            const handleBatchResponse = (e) => {
                const { type } = e.data;
                
                if (type === 'BATCH_COMPLETE' || type === 'INDIVIDUAL_BATCH_COMPLETE') {
                    worker.removeEventListener('message', handleBatchResponse);
                    resolve();
                } else if (type === 'BATCH_ERROR') {
                    worker.removeEventListener('message', handleBatchResponse);
                    // Don't reject here - let the error handler in the message listener deal with it
                    resolve(); // Resolve to prevent hanging
                } else if (type === 'PAGE_ERROR') {
                    worker.removeEventListener('message', handleBatchResponse);
                    // Don't reject here - let the error handler in the message listener deal with it
                    resolve(); // Resolve to prevent hanging
                } else if (type === 'ERROR') {
                    worker.removeEventListener('message', handleBatchResponse);
                    reject(new Error(e.data.error));
                }
            };
            
            worker.addEventListener('message', handleBatchResponse);
            
            worker.postMessage({
                type: 'PROCESS_BATCH',
                data: { 
                    startIndex: i, 
                    endIndex,
                    skipList: Array.from(processingState.skippedPages),
                    individualMode: individualMode
                }
            });
        });
        
        // If we're in individual mode and completed this batch, switch back to normal mode
        if (individualMode && i + batchSize >= processingState.totalPages) {
            processingState.individualMode = false;
        }
    }
    
    // If we completed all batches without error, get final results
    if (startIndex === 0 || !processingState.currentErrorBatch) {
        updateStatus('All batches processed, getting final results...', true);
        worker.postMessage({ type: 'GET_RESULTS' });
    }
}

async function continueIndividualProcessing(fromPage) {
    if (!processingState.currentErrorBatch) {
        updateStatus('No error batch context for individual processing', false, 'error');
        return;
    }
    
    const { start, end } = processingState.currentErrorBatch;
    console.log(` Start of Individual ${start} to ${end}`);
    // Continue individual processing from the specified page within the error batch
    const adjustedStart = Math.max(start, fromPage);
    
    if (adjustedStart >= end) {
        // We've completed the error batch, continue with normal batch processing
        updateStatus('Error batch completed, returning to normal batch mode...', true);
        processingState.individualMode = false;
        continueProcessingFromBatch(end, false);
        return;
    }
    
    updateStatus(`Continuing individual processing from page ${adjustedStart + 1} in error batch...`, true);
    
    worker.postMessage({
        type: 'PROCESS_BATCH',
        data: { 
            startIndex: adjustedStart, 
            endIndex: end,
            skipList: Array.from(processingState.skippedPages),
            individualMode: true
        }
    });
}

// Initialize worker
function initWorker() {
    return new Promise((resolve, reject) => {
        try {
            worker = new Worker('worker.js');
        } catch (error) {
            console.warn('Could not load worker.js');
            return
        }
        
        worker.onmessage = function(e) {
            const { type, current, total, index, sortedPages: results, error, pageIndex, pageData, partialResults, batchStart, batchEnd } = e.data;
            
            switch (type) {
                case 'STATUS':
                    updateStatus(e.data.message);
                    break;
                    
                case 'WASM_READY':
                    resolve();
                    break;
                    
                case 'IMAGE_ADDED':
                    // Handle individual image completion if needed
                    break;
                    
                case 'PAGE_COMPLETE':
                    updateStatus(`Successfully processed page ${pageIndex}`);
                    updateProgress(current, total, 'process');
                    
                    // Store partial results as we go
                    if (pageData) {
                        try {
                            // Merge page data into partial results
                            Object.assign(processingState.partialResults, pageData);
                        } catch (e) {
                            console.warn('Failed to merge page data:', e);
                        }
                    }
                    break;
                    
                case 'PAGE_SKIPPED':
                    updateStatus(`Skipped page ${pageIndex} as requested`, false, 'warning');
                    break;
                    
                case 'PAGE_ERROR':
                    const errorMsg = `Error processing page ${pageIndex}: ${error}`;
                    updateStatus(errorMsg, false, 'error');
                    
                    // Store the current error context
                    processingState.currentErrorBatch = { start: batchStart, end: batchEnd };
                    processingState.currentErrorPage = pageIndex;
                    
                    // Request partial results before showing recovery options
                    worker.postMessage({ type: 'GET_PARTIAL_RESULTS' });
                    
                    // Show error recovery after a short delay
                    setTimeout(() => {
                        showErrorRecovery();
                    }, 1000);
                    break;
                    
                case 'BATCH_COMPLETE':
                    updateStatus(`Batch processed: ${current} of ${total} pages`);
                    updateProgress(current, total, 'process');
                    break;
                    
                case 'INDIVIDUAL_BATCH_COMPLETE':
                    updateStatus(`Individual batch completed: ${current} of ${total} pages processed`);
                    updateProgress(current, total, 'process');
                    
                    // Continue with next batch in normal mode
                    continueProcessingFromBatch(batchEnd, false);
                    break;
                    
                case 'BATCH_ERROR':
                    const batchErrorMsg = `Batch error (pages ${batchStart}-${batchEnd}): ${error}`;
                    updateStatus(batchErrorMsg, false, 'error');
                    
                    // Store the error context
                    processingState.currentErrorBatch = { start: batchStart, end: batchEnd };
                    
                    // Request partial results and show recovery options
                    worker.postMessage({ type: 'GET_PARTIAL_RESULTS' });
                    
                    setTimeout(() => {
                        showErrorRecovery();
                    }, 1000);
                    break;
                    
                case 'PARTIAL_RESULTS':
                    // Update partial results
                    processingState.partialResults = { ...processingState.partialResults, ...partialResults };
                    updateProgressJSON();
                    break;
                    
                case 'TOTAL_IMAGES':
                    processingState.totalPages = e.data.total;
                    break;
                    
                case 'RESULTS_READY':
                    sortedPages = results;
                    console.log('Final results:', results);
                    updateStatus('Processing complete!', false, 'info');
                    setTimeout(() => {
                        hideProgress();
                        hideErrorRecovery();
                        processingComplete();
                    }, 1000);
                    break;
                    
                case 'ERROR':
                    updateStatus('Worker error: ' + error, false, 'error');
                    
                    // Request partial results before showing recovery
                    worker.postMessage({ type: 'GET_PARTIAL_RESULTS' });
                    
                    setTimeout(() => {
                        showErrorRecovery();
                    }, 1000);
                    
                    console.error('Worker error:', error);
                    break;
            }
        };
        
        worker.onerror = function(error) {
            updateStatus('Worker initialization error: ' + error.message, false, 'error');
            reject(error);
        };
        
        // Initialize WASM in worker
        worker.postMessage({ type: 'INIT_WASM' });
    });
}

// Process PDF in main thread, send images to worker
async function processPDF(pdfBytes) {
    try {
        processingState.processingStarted = true;
        updateStatus('Loading PDF...');
        
        // Configure PDF.js in main thread
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        const pdf = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
        processingState.totalPages = pdf.numPages;
        
        updateStatus('Rendering pages...');
        images.length = 0; // Clear existing images
        
        // Render all pages in main thread with error handling
        for (let i = 1; i <= pdf.numPages; i++) {
            try {
                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: 2.5 });
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                
                await page.render({ canvasContext: ctx, viewport }).promise;
                
                // Get image data and send to worker
                const imgData = ctx.getImageData(0, 0, viewport.width, viewport.height);
                
                // Store image for UI display
                images.push(canvas.toDataURL());
                
                // Send image data to worker with error handling
                try {
                    worker.postMessage({
                        type: 'ADD_IMAGE',
                        data: {
                            imageData: imgData.data,
                            width: viewport.width,
                            height: viewport.height,
                            index: i
                        }
                    });
                } catch (workerError) {
                    updateStatus(`Error sending page ${i} to worker: ${workerError.message}`, false, 'error');
                    showErrorRecovery();
                    return;
                }
                
                updateStatus(`Rendered page ${i} of ${pdf.numPages}`);
                updateProgress(i, pdf.numPages, 'render');
                
            } catch (pageError) {
                const errorMsg = `Error rendering page ${i}: ${pageError.message}`;
                updateStatus(errorMsg, false, 'error');
                
                // Add a placeholder image for the failed page
                images.push('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100"><text x="50" y="50" text-anchor="middle">Error</text></svg>');
                
                // Continue with next page
                continue;
            }
        }
        
        updateStatus('Starting QR code detection...');
        
        // Process images in batches using worker with error handling
        await continueProcessingFromBatch(0, false);
        
    } catch (error) {
        updateStatus('PDF processing error: ' + error.message, false, 'error');
        showErrorRecovery();
        console.error('Processing error:', error);
    }
}

async function processingComplete() {
    try {
        await splitPdfAndCreateDownloads(sortedPages);
        
        if (sortedPages["Error"] && sortedPages["Error"].length > 0) {
            renderManualAssignmentUI(sortedPages["Error"], sortedPages);
        }
        
        // Clear processing state on successful completion
        processingState.processingStarted = false;
        
    } catch (error) {
        updateStatus('Error completing processing: ' + error.message, false, 'error');
        showErrorRecovery();
    }
}

async function splitPdfAndCreateDownloads(sortedPages) {
  try {
    const zip = new JSZip();
    const file = document.getElementById('fileInput').files[0]
    originalPdfBytes = await file.arrayBuffer();
    
    const pdfDoc = await PDFLib.PDFDocument.load(originalPdfBytes);
    const numPages = pdfDoc.getPageCount();
    const downloadsDiv = document.getElementById('downloads');
    const carouselGrid = document.getElementById('carouselGrid');

    downloadsDiv.innerHTML = '';
    carouselGrid.innerHTML = '';

    for (const docName in sortedPages) {
      if (docName === "Error") continue;

      try {
        const pagesData = sortedPages[docName];
        pagesData.sort((a,b) => a.pageno - b.pageno);

        const newPdfDoc = await PDFLib.PDFDocument.create();
        const docImages = [];

        for (const p of pagesData) {
          if (p.foundpage >= numPages) continue;
          
          try {
            const [copiedPage] = await newPdfDoc.copyPages(pdfDoc, [p.foundpage]);
            newPdfDoc.addPage(copiedPage);
            docImages.push(images[p.foundpage]);
          } catch (pageError) {
            logError(`Error copying page ${p.foundpage} for document ${docName}: ${pageError.message}`);
            continue;
          }
        }

        const pdfBytes = await newPdfDoc.save();
        const blob = new Blob([pdfBytes], { type: 'application/pdf' });
        zip.file(`${docName}.pdf`, blob);

        const col = document.createElement('div');
        col.className = 'col-md-6 col-lg-4';

        const carouselId = `carousel-${docName}`;
        const indicators = docImages.map((_, idx) =>
          `<button type="button" data-bs-target="#${carouselId}" data-bs-slide-to="${idx}" ${idx === 0 ? 'class="active"' : ''}></button>`
        ).join("");

        const slides = docImages.map((src, idx) =>
          `<div class="carousel-item ${idx === 0 ? 'active' : ''}">
            <img src="${src}" class="d-block w-100" style="max-height: 300px; object-fit: contain;">
          </div>`
        ).join("");

        col.innerHTML = `
          <div class="card h-100">
            <div id="${carouselId}" class="carousel slide" data-bs-ride="carousel">
              <div class="carousel-indicators">${indicators}</div>
              <div class="carousel-inner">${slides}</div>
              <button class="carousel-control-prev" type="button" data-bs-target="#${carouselId}" data-bs-slide="prev">
                <span class="carousel-control-prev-icon"></span>
              </button>
              <button class="carousel-control-next" type="button" data-bs-target="#${carouselId}" data-bs-slide="next">
                <span class="carousel-control-next-icon"></span>
              </button>
            </div>
            <div class="card-body text-center">
              <h5 class="card-title">${docName}</h5>
              <a class="btn btn-primary" download="${docName}.pdf" href="${URL.createObjectURL(blob)}">Download PDF</a>
            </div>
          </div>`;

        carouselGrid.appendChild(col);
        
      } catch (docError) {
        logError(`Error creating document ${docName}: ${docError.message}`);
        continue;
      }
    }

    zip.generateAsync({ type: "blob" }).then((blob) => {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = "sorted_pdfs.zip";
      a.style = "width:100%";
      a.className = "btn btn-success mb-3";
      a.textContent = "Download All Files";
      downloadsDiv.appendChild(a);
    }).catch((zipError) => {
      logError(`Error creating ZIP file: ${zipError.message}`);
    });
    
  } catch (error) {
    updateStatus('Error creating downloads: ' + error.message, false, 'error');
    throw error;
  }
}

let activeIndex = null;
function showImageModal(index,imageSrc) {
  activeIndex = index;
  const existingInput = document.getElementById(`input-${index}`);
  document.getElementById("correctionInput").value = existingInput ? existingInput.value : '';
  document.getElementById("previewImage").src = imageSrc;
  const modal = new bootstrap.Modal(document.getElementById('imagePreviewModal'));
  modal.show();
}

function syncCorrectionInput() {
  const newValue = document.getElementById("correctionInput").value;
  const inputEl = document.getElementById(`input-${activeIndex}`);
  const selectEl = document.getElementById(`select-${activeIndex}`);

  if (inputEl && selectEl) {
    inputEl.value = newValue;
    inputEl.style.display = 'block';
    selectEl.value = '_new';
  }
}

function renderManualAssignmentUI(errorPages, sortedPages) {
  const output = document.getElementById('output');
  const container = document.createElement('div');
  container.className = 'mt-4';
  container.innerHTML = `<h3>Unassigned Pages</h3>`;

  const assignments = {};

  errorPages.forEach((pageData, index) => {
    const card = document.createElement('div');
    card.className = 'card mb-3 bg-white text-dark';
    card.innerHTML = `
      <div class="row g-0">
        <div class="col-md-4 text-center">
          <img src="${images[pageData.foundpage]}" class="img-fluid rounded-start" style="max-height: 200px; object-fit: contain; cursor: zoom-in;" onclick="showImageModal(${index},'${images[pageData.foundpage]}')">
        </div>
        <div class="col-md-8">
          <div class="card-body">
            <h5 class="card-title">Page #${pageData.pageno}</h5>
            <p class="card-text">No QR ID found. Assign to a document:</p>

            <label>Select existing or create new:</label>
            <select class="form-select mb-2" id="select-${index}">
              <option value="">-- Select Document --</option>
              ${Object.keys(sortedPages).map(name => `<option value="${name}">${name}</option>`).join('')}
              <option value="_new">[Create New]</option>
            </select>

            <input type="text" id="input-${index}" class="form-control mb-2" placeholder="New document name" style="display:none;">
            <input type="number" min="1" class="form-control mb-2" id="pageno-${index}" placeholder="Insert at page (optional)">

            <button class="btn btn-sm btn-outline-primary" onclick="assignPage(${index})">Assign</button>
          </div>
        </div>
      </div>
    `;
    container.appendChild(card);

    const select = card.querySelector(`#select-${index}`);
    const input = card.querySelector(`#input-${index}`);

    select.addEventListener('change', () => {
      input.style.display = (select.value === '_new') ? 'block' : 'none';
    });
  });

  const rerunBtn = document.createElement('button');
  rerunBtn.className = 'btn btn-success mt-3';
  rerunBtn.textContent = 'Re-run Split with Manual Assignments';
  rerunBtn.onclick = async () => {
    try {
      for (const docName in assignments) {
        if (!sortedPages[docName]) sortedPages[docName] = [];
        sortedPages[docName].push(...assignments[docName]);
      }
      sortedPages["ErrorOld"] = sortedPages["Error"];
      delete sortedPages["Error"];
      await splitPdfAndCreateDownloads(sortedPages);
      container.remove();
    } catch (error) {
      updateStatus('Error re-running split: ' + error.message, false, 'error');
    }
  };

  container.appendChild(rerunBtn);
  output.appendChild(container);

  window.assignPage = (index) => {
    const select = document.getElementById(`select-${index}`);
    const input = document.getElementById(`input-${index}`);
    const pagenoInput = document.getElementById(`pageno-${index}`);

    const docName = (select.value === '_new') ? input.value.trim() : select.value;
    const insertPageNum = parseInt(pagenoInput.value);

    if (!docName) {
      alert("Please enter or select a document name.");
      return;
    }

    if (!assignments[docName]) assignments[docName] = [];

    const targetList = assignments[docName];
    const page = errorPages[index];

    if (insertPageNum > 0 && insertPageNum <= targetList.length + 1) {
      targetList.splice(insertPageNum - 1, 0, page);
    } else {
      targetList.push(page);
    }

    select.disabled = true;
    input.disabled = true;
    pagenoInput.disabled = true;
    select.nextElementSibling.nextElementSibling.nextElementSibling.disabled = true;
    select.closest('.card').classList.add('border-success');
  };
}

// File input handler
document.getElementById('fileInput').addEventListener('change', async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  
  try {
    // Reset state for new file
    resetProcessing();
    
    originalPdfBytes = await file.arrayBuffer();
    showProgress();
    updateStatus('Initializing worker...');
    
    // Initialize worker if not already done
    if (!worker) {
      await initWorker();
    }
    
    // Start processing
    await processPDF(originalPdfBytes);
    
  } catch (error) {
    updateStatus('File processing error: ' + error.message, false, 'error');
    showErrorRecovery();
    console.error('Processing error:', error);
  }
});

// Initialize worker on page load
document.addEventListener('DOMContentLoaded', async () => {
  try {
    await initWorker();
    console.log('Worker initialized successfully');
  } catch (error) {
    console.error('Failed to initialize worker:', error);
    updateStatus('Failed to initialize worker: ' + error.message, false, 'error');
  }
});
</script>
</body>
</html>
